<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>自律小盾宇 × Blog</title>
    <link>https://dunyusong.github.io/</link>
    
    <atom:link href="https://dunyusong.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>Art and beauty can be created on a computer.</description>
    <pubDate>Sun, 25 Jun 2023 15:58:31 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Webpack与性能优化-学习笔记</title>
      <link>https://dunyusong.github.io/post/Webpack%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</link>
      <guid>https://dunyusong.github.io/post/Webpack%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</guid>
      <pubDate>Sun, 25 Jun 2023 13:31:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;报名了&lt;a href=&quot;https://xiedaimala.com/courses/7a2efc7f-ac70-4fa7-b75c-f913e334c4ff/random/56c3135282#/common&quot;&gt;饥人谷的前端课程&lt;/a&gt;，在学习的过程中，一些我觉得比较简单</description>
        
      
      
      
      <content:encoded><![CDATA[<p>报名了<a href="https://xiedaimala.com/courses/7a2efc7f-ac70-4fa7-b75c-f913e334c4ff/random/56c3135282#/common">饥人谷的前端课程</a>，在学习的过程中，一些我觉得比较简单的内容，就直接使用AI来进行解释和举例，遇到不懂的地方继续提问就好，这样就直接跳过视频学习了，省一些时间。以下内容由AI生成，记录方便我复习。</p><p>参考这个目录来进行学习：</p><img src="/post/Webpack%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Webpack%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.png" class alt="Webpack与性能优化"><h1 id="长期缓存是什么？并举例"><a href="#长期缓存是什么？并举例" class="headerlink" title="长期缓存是什么？并举例"></a>长期缓存是什么？并举例</h1><p>当谈到Web性能优化时，长期缓存是一种被广泛使用的策略，用于减少网页加载时间并提升用户体验。长期缓存是指在客户端（通常是浏览器）保存资源文件的副本，并在后续的请求中重复使用这些副本，而不是每次请求都从服务器重新下载资源。这样可以减少网络请求的数量，降低服务器负载，并加快网页的加载速度。</p><p>在前端开发中，常见的需要长期缓存的资源包括 JavaScript 文件、CSS 文件、图片和字体等静态资源。这些资源文件通常在构建项目时由Webpack等构建工具生成，并在浏览器中引用。</p><p>通过为这些资源文件生成唯一的哈希值或版本号，并将其作为文件名的一部分，可以实现长期缓存。当文件内容发生变化时，哈希值或版本号也会更新，以确保客户端缓存的是最新的文件。这使得客户端在更新项目时只需要下载变化了的文件，而不必重新下载所有资源。</p><p>下面是一个具体的例子：</p><p>假设你正在开发一个网站，并使用Webpack构建工具打包资源。在构建过程中，Webpack会为生成的JavaScript文件添加哈希值：</p><ul><li>Before: main.js</li><li>After: main.e6a2c1df.js</li></ul><p>在网页中引用该文件时，你会使用带有哈希值的文件名：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;main.e6a2c1df.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当你进行修改并重新构建时，Webpack会为新生成的文件添加新的哈希值：</p><ul><li>Before: main.e6a2c1df.js</li><li>After: main.143f29b9.js</li></ul><p>此时，浏览器会根据先前缓存的文件名进行检查，发现文件名已经发生了变化，从而清楚旧的缓存，并下载新的文件。这样，客户端就能获取到更新后的资源文件，同时仍然能够从缓存中加载其他没有变化的文件，从而提高加载速度。</p><p>通过长期缓存策略，可以有效地减少网络请求并加快网页加载速度，从而提高用户体验。</p><h2 id="举个例子，什么业务会用到长期缓存？"><a href="#举个例子，什么业务会用到长期缓存？" class="headerlink" title="举个例子，什么业务会用到长期缓存？"></a>举个例子，什么业务会用到长期缓存？</h2><p>长期缓存在许多不同类型的业务中都有广泛应用。以下是一些常见的业务场景和示例：</p><p>静态网页或博客：对于纯静态内容的网页或博客，例如使用HTML和CSS构建的页面，可以将这些资源文件进行长期缓存。由于这些资源文件很少变化，通过使用适当的缓存策略，可以减少网络请求并提高加载速度。<br>电子商务网站：对于电子商务网站，商品图片、加载脚本、CSS样式等静态资源可能会被频繁访问且长时间不变。通过为这些资源文件生成唯一的哈希值或版本号，并设置适当的缓存策略，可以使客户端能够长期缓存这些资源，从而提升用户的浏览体验。<br>社交媒体平台：社交媒体平台通常涉及大量的图像、头像、视频和音频文件。对于这些静态资源文件，可以使用长期缓存策略来减少服务器负载，提高平台的响应速度，并提升用户的体验。<br>Web应用程序：Web应用程序通常包含多个页面、脚本和样式文件。通过使用长期缓存策略，可以让浏览器缓存这些资源文件，从而减少网络请求次数，提高用户访问速度，并降低服务器负载。</p><p>总之，几乎所有需要加载静态资源的业务都可以从长期缓存中受益。通过合理设置资源文件的缓存策略，可以减少网络流量，提高用户页面加载速度，减轻服务器负载，并提供更好的用户体验。</p><h1 id="给文件名添加content-hash是什么意思？举例说明"><a href="#给文件名添加content-hash是什么意思？举例说明" class="headerlink" title="给文件名添加content hash是什么意思？举例说明"></a>给文件名添加content hash是什么意思？举例说明</h1><p>将文件名添加内容哈希是一种常见的做法，用于确保文件的唯一性和版本控制。它基于文件的内容生成一个唯一的哈希值，并将该哈希值与文件名结合起来形成一个新的文件名。</p><p>下面是一个示例说明：</p><p>假设有一个静态资源文件，名为”styles.css”，它用于定义网页的样式。为了确保更新样式文件时浏览器重新请求并加载最新的文件，可以为文件名添加内容哈希。</p><ol><li>首先，计算样式文件的内容哈希值。可以使用各种哈希算法，如MD5、SHA-1或SHA-256等。假设计算得到的哈希值为”abcdefg”.</li><li>将哈希值添加到文件名中。在这个示例中，可以将新的文件名设置为”styles.abcdefg.css”。</li><li>更新网页中引用样式文件的链接，将原始文件名”styles.css”更改为新的文件名”styles.abcdefg.css”。</li></ol><p>通过引入内容哈希值，每次文件内容发生变化时，都会生成一个新的文件名。这样，当浏览器检测到文件名变化时，它将认为是一个新的文件，从而强制重新下载文件而不是从缓存中获取。</p><p>这种方式可以确保浏览器始终获取到最新的文件版本，避免使用过期的缓存内容。同时，它也可以帮助开发人员进行版本控制，以确保网页在更新时正确加载新的样式文件。</p><p>值得注意的是，对于静态资源文件的内容变化频率较低的情况，可以将缓存时间设置较长，以减少客户端的请求。只有在文件内容发生实质性变化时才更新内容哈希，以保证最佳性能和缓存效果。</p><h1 id="如何使用WebpackManifestPlugin？举例"><a href="#如何使用WebpackManifestPlugin？举例" class="headerlink" title="如何使用WebpackManifestPlugin？举例"></a>如何<strong>使用WebpackManifestPlugin？举例</strong></h1><p>WebpackManifestPlugin是一个用于生成资产清单（Manifest）的插件，它可以提供生成的文件与其对应的哈希值的映射关系，以及其他相关信息。在Webpack构建过程中使用WebpackManifestPlugin可以很方便地获得生成文件的信息，进而实现更精确的缓存管理和资源定位。</p><p>下面是一个使用WebpackManifestPlugin的例子：</p><ol><li><p>安装插件：</p><p>在项目的根目录下执行以下命令来安装WebpackManifestPlugin：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-manifest-plugin</span><br></pre></td></tr></table></figure></li><li><p>在Webpack配置文件中引入插件：</p><p>在Webpack配置文件（通常为webpack.config.js）中引入WebpackManifestPlugin：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; WebpackManifestPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-manifest-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 其他配置项...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> WebpackManifestPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>设置输出文件名：</p><p>WebpackManifestPlugin默认会将生成的资产清单输出为manifest.json文件。如果你想自定义输出的文件名和路径，可以传入options配置给插件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> WebpackManifestPlugin(&#123;</span><br><span class="line">    <span class="attr">fileName</span>: <span class="string">&#x27;my-manifest.json&#x27;</span>,</span><br><span class="line">    <span class="comment">// 其他选项...</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>构建项目：</p><p>在终端中运行Webpack构建命令，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure></li><li><p>查看生成的资产清单：</p><p>构建成功后，你将看到在输出目录中生成了指定文件名的资产清单。打开这个文件，你将看到类似以下的内容：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;main.js&quot;</span>: <span class="string">&quot;main.3421e8d4.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;styles.css&quot;</span>: <span class="string">&quot;styles.0987c5a1.css&quot;</span>,</span><br><span class="line">  <span class="string">&quot;image.png&quot;</span>: <span class="string">&quot;image.ee56b319.png&quot;</span>,</span><br><span class="line">  <span class="comment">// 其他生成的文件与哈希值的映射关系...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个资产清单提供了生成的文件与其对应的哈希值的映射关系，你可以读取和解析这个文件，根据哈希值来动态加载资源或生成合适的文件引用路径。</p></li></ol><p>WebpackManifestPlugin的主要作用是为了方便在构建过程中生成资产清单，以便在需要时可以根据清单内容进行更精准的资源管理和定位。</p><h1 id="如何使用HtmlWebpackPlugin？举例"><a href="#如何使用HtmlWebpackPlugin？举例" class="headerlink" title="如何使用HtmlWebpackPlugin？举例"></a>如何使用HtmlWebpackPlugin？举例</h1><p>HtmlWebpackPlugin是一个用于生成HTML文件的插件，它可以与Webpack一起使用，自动将生成的打包文件（如JavaScript和CSS）插入到HTML模板中，并输出一个最终的HTML文件。这使得在构建过程中无需手动更新HTML文件，提高了开发效率。</p><p>下面是一个使用HtmlWebpackPlugin的例子：</p><ol><li><p>安装插件：</p><p>在项目的根目录下执行以下命令来安装HtmlWebpackPlugin：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure></li><li><p>在Webpack配置文件中引入插件：</p><p>在Webpack配置文件（通常为webpack.config.js）中引入HtmlWebpackPlugin：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 其他配置项...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>配置插件：</p><p>HtmlWebpackPlugin提供了许多配置选项，以满足不同的需求。你可以传入一个模板文件、指定输出的文件名、自定义标题等配置。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;src/index.html&#x27;</span>, <span class="comment">// 指定模板文件</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;index.html&#x27;</span>, <span class="comment">// 输出文件名，默认为 index.html</span></span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;My App&#x27;</span>, <span class="comment">// HTML文件的标题</span></span><br><span class="line">    <span class="comment">// 其他选项...</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>创建HTML模板文件：</p><p>在指定的模板文件（上述示例中为’src/index.html’）中，你可以编写HTML代码，包括页面布局、样式、脚本标签的引入等。插件会将打包生成的文件自动插入到这个模板中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/index.html --&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>构建项目：</p><p>在终端中运行Webpack构建命令，例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>HtmlWebpackPlugin会在构建过程中根据提供的模板文件自动生成一个最终的HTML文件，并将生成的打包文件（如JavaScript和CSS）插入到其中。这个文件将被输出到指定的输出目录中。</p></li></ol><p>HtmlWebpackPlugin在生成HTML文件时还提供了一些其他功能，例如自动引入打包后的文件、生成带哈希值的文件名、生成多个HTML文件等。你可以根据实际需求配置和使用这些功能。</p><p>总之，HtmlWebpackPlugin使得在Webpack构建过程中自动生成HTML文件变得简单，并提供了灵活的配置选项以适应不同的项目需求。</p><h1 id="Webpack打包加速怎么用？举例"><a href="#Webpack打包加速怎么用？举例" class="headerlink" title="Webpack打包加速怎么用？举例"></a><strong>Webpack打包加速怎么用？举例</strong></h1><p>对于Webpack打包的加速，以下是一些常用的方法和技巧：</p><ol><li><p>使用Webpack的生产模式：</p><p>在Webpack配置文件中设置<code>mode</code>为<code>production</code>，这会启用一系列的优化选项，如代码压缩、作用域提升等。生产模式下的打包速度通常会比开发模式快很多。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">  <span class="comment">// 其他配置...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用多线程/多实例打包工具：</p><p>可以使用一些多线程/多实例的打包工具，如<code>parallel-webpack</code>、<code>happypack</code>等，将任务并行处理，从而加快打包速度。这些工具可以将任务拆分为多个子任务，在多个线程或进程中同时处理，提高打包效率。</p></li><li><p>减少不必要的资源解析：</p><p>配置Webpack来减少不必要的资源解析，例如通过<code>resolve.extensions</code>指定解析文件时优先尝试的后缀名，避免Webpack尝试解析不需要的文件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>],</span><br><span class="line">    <span class="comment">// 其他配置...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 其他配置...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用缓存：</p><p>配置Webpack的缓存选项可以利用缓存，避免重复的文件解析和编译。可以使用<code>cache-loader</code>、<code>hard-source-webpack-plugin</code>等插件来启用缓存功能。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 其他配置...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;cache-loader&#x27;</span>, <span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">        <span class="comment">// 其他配置...</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 其他配置...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>按需加载（Code Splitting）：</p><p>通过按需加载将代码拆分成多个小块，按需加载可以减少打包的文件大小和数量，从而加快加载速度。可以使用Webpack提供的动态导入语法、<code>SplitChunksPlugin</code>等方式来实现按需加载。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./module&quot;</span>).then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用异步加载的模块</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>配置文件的压缩：</p><p>在Webpack配置文件中，可以使用<code>TerserPlugin</code>、<code>OptimizeCSSAssetsPlugin</code>等插件来压缩代码文件和CSS文件，减小文件大小，进而加快打包速度。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 其他配置...</span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> TerserPlugin(),</span><br><span class="line">      <span class="keyword">new</span> OptimizeCSSAssetsPlugin(),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>以上是一些Webpack打包加速的常见方法和技巧。根据具体的项目和需求，可能还有其他针对性的优化策略可以使用。记住，打包速度的提升需要综合考虑配置选项、代码拆分、缓存和资源优化等方面的优化策略。</p>]]></content:encoded>
      
      
      <category domain="https://dunyusong.github.io/categories/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <category domain="https://dunyusong.github.io/tags/Webpack/">Webpack</category>
      
      
      <comments>https://dunyusong.github.io/post/Webpack%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Webpack的使用-学习笔记</title>
      <link>https://dunyusong.github.io/post/Webpack%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</link>
      <guid>https://dunyusong.github.io/post/Webpack%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</guid>
      <pubDate>Sun, 25 Jun 2023 13:11:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;报名了&lt;a href=&quot;https://xiedaimala.com/courses/7a2efc7f-ac70-4fa7-b75c-f913e334c4ff/random/56c3135282#/common&quot;&gt;饥人谷的前端课程&lt;/a&gt;，在学习的过程中，一些我觉得比较简单</description>
        
      
      
      
      <content:encoded><![CDATA[<p>报名了<a href="https://xiedaimala.com/courses/7a2efc7f-ac70-4fa7-b75c-f913e334c4ff/random/56c3135282#/common">饥人谷的前端课程</a>，在学习的过程中，一些我觉得比较简单的内容，就直接使用AI来进行解释和举例，遇到不懂的地方继续提问就好，这样就直接跳过视频学习了，省一些时间。以下内容由AI生成，记录方便我复习。</p><p>参考这个目录来进行学习：</p><h1 id="什么是webpack，为什么要用这个？"><a href="#什么是webpack，为什么要用这个？" class="headerlink" title="什么是webpack，为什么要用这个？"></a>什么是webpack，为什么要用这个？</h1><p>当你开始学习前端开发时，你可能会听到关于Webpack的名字。Webpack（发音为”weh-bak”）是一个开源的静态模块打包工具，用于将前端项目中的各种资源（如HTML、CSS、JavaScript、图片等）打包成一个或多个静态文件。</p><p>那为什么我们要使用Webpack呢？Webpack带来了一些重要的好处和功能，帮助我们在前端开发中更高效地工作：</p><ol><li>模块化开发：Webpack支持使用模块化的开发方式，这意味着你可以将代码拆分成小块（例如组件）并单独管理，提高代码的可维护性和重用性。</li><li>资源打包：Webpack可以将多个文件（例如CSS、JavaScript、图片等）合并成一个或多个打包后的输出文件。这样可以减少网络请求的数量，提高网页加载速度。</li><li>代码转换：Webpack可以通过使用不同的Loader将各种类型的文件转换为浏览器可以识别的格式。例如，可以使用Babel Loader将最新版本的JavaScript代码转换为旧版浏览器可执行的代码。</li><li>代码优化：Webpack提供了各种优化功能，例如代码压缩、去除无用代码等，以减小文件大小，提高网页性能。</li><li>开发环境支持：Webpack具有内置的开发服务器，可以为你提供一个方便的开发环境，并支持热模块替换（Hot Module Replacement）功能，使得在修改代码后无需刷新整个页面就可以立即看到变化。</li></ol><p>总结来说，Webpack是一个功能强大的前端构建工具，可以帮助你在前端开发中更好地处理模块化、打包、转换和优化等工作。它是现代前端开发中不可或缺的一部分，能够提升你的开发效率和项目的性能。当然，随着你的学习和经验的增长，你会更深入地了解Webpack的更多功能和用法。</p><h1 id="Webpack的入口、出口、模式，都是什么意思？干什么用的？帮我详细解释并举例"><a href="#Webpack的入口、出口、模式，都是什么意思？干什么用的？帮我详细解释并举例" class="headerlink" title="Webpack的入口、出口、模式，都是什么意思？干什么用的？帮我详细解释并举例"></a>Webpack的入口、出口、模式，都是什么意思？干什么用的？帮我详细解释并举例</h1><p>当使用Webpack进行项目构建时，我们需要配置一些重要的选项，其中包括入口（entry）、出口（output）和模式（mode）。让我详细解释一下它们的含义和用途，并给出一些示例说明：</p><ol><li>入口（entry）：入口是Webpack构建过程中指定的起点文件，它标识Webpack应该从哪个文件开始构建依赖图。你可以将入口文件看作是整个项目的主入口。</li></ol><p>示例：</p><p>假设你的项目根目录下有一个名为<code>index.js</code>的文件，你可以将其配置为Webpack的入口文件。Webpack会从该文件开始构建依赖图，并解析它所引入的其他模块。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./index.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...其他配置选项</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>出口（output）：出口是Webpack构建过程中生成的文件的输出配置。它指定了Webpack应该将打包后的文件输出到哪个目录，并且可以指定输出文件的命名规则。</li></ol><p>示例：</p><p>假设你希望Webpack将打包后的文件输出到一个名为<code>dist</code>的目录下，并将输出文件命名为<code>bundle.js</code>，可以进行如下配置：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...其他配置选项</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述示例中，通过<code>path.resolve</code>方法将输出目录<code>dist</code>与当前配置文件的路径进行拼接，生成了一个绝对路径。</p><ol><li>模式（mode）：模式是指定Webpack的构建模式，它控制了Webpack的一些默认配置和优化策略。Webpack提供了三种模式：开发模式（development）、生产模式（production）和测试模式（none）。</li></ol><ul><li>开发模式（development）：在开发模式下，Webpack会开启一些便于调试和快速构建的特性，例如对代码的压缩和优化程度较低，方便定位错误和查看源代码。适合在开发阶段使用。</li><li>生产模式（production）：在生产模式下，Webpack会对代码进行压缩、合并、混淆等优化，生成最终用于部署的高效代码。适合在项目准备部署上线时使用。</li><li>测试模式（none）：在测试模式下，Webpack不会应用任何默认的优化，保持原始的打包输出。适合在特殊情况下进行自定义的构建设置。</li></ul><p>示例：</p><p>在配置文件中设置模式选项的值为<code>development</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 设置为开发模式</span></span><br><span class="line">  <span class="comment">// ...其他配置选项</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过使用这些选项，你可以根据项目的需求和阶段来配置Webpack，并实现更精确地控制构建过程。请注意，上述示例中的配置是简化的，并不包含所有可能的选项，你可以根据需要进行扩展和自定义。</p><h1 id="webpack-watch是什么意思？帮我详细解释并举例说明"><a href="#webpack-watch是什么意思？帮我详细解释并举例说明" class="headerlink" title="webpack watch是什么意思？帮我详细解释并举例说明"></a>webpack watch是什么意思？帮我详细解释并举例说明</h1><p><code>webpack watch</code> 是Webpack提供的一个功能，用于监听文件的变化并自动重新构建项目。它可以在开发过程中实时监测文件的修改，并自动重新构建和更新输出文件，以便你能够快速查看和验证修改的效果，而无需手动运行构建命令。</p><p>当你使用 <code>webpack watch</code> 命令时，Webpack会启动一个持续监视的进程，它会监听你指定的文件或目录，一旦文件发生更改，Webpack将自动重新运行构建过程，并生成更新后的输出文件。</p><p>以下是 <code>webpack watch</code> 的详细解释和示例说明：</p><ol><li><p><code>webpack watch</code> 的使用说明：</p><ul><li>通过在终端中执行 <code>webpack watch</code> 命令，可以启动Webpack的监听模式。</li><li>当文件发生更改时，Webpack会在后台自动重新构建项目，但不会停止进程。</li><li>你需要手动刷新页面或重新加载相关资源才能看到更改后的结果。</li></ul></li><li><p>示例：</p><p>假设你有一个Webpack配置文件 <code>webpack.config.js</code>，其中的入口文件是 <code>index.js</code>，你可以通过以下命令来使用 <code>webpack watch</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack watch</span><br></pre></td></tr></table></figure><p>这会启动Webpack的监听模式，并开始监视文件的变化。当 <code>index.js</code> 文件或其依赖的模块发生更改时，Webpack将重新构建项目并更新输出文件。</p><p>你可以对代码进行修改并保存，然后在浏览器中查看结果。例如，如果你的项目输出一个 <code>bundle.js</code> 文件用于页面引入，你可以在HTML文件中添加一个 <code>&lt;script&gt;</code> 标签来加载该文件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;dist/bundle.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当你使用 <code>webpack watch</code> 时，你可以在编辑代码后保存，然后观察Webpack在终端中输出的信息。它会显示重新构建的过程和输出的文件路径。</p><p>这样，你就可以在开发过程中保持Webpack处于监听状态，随时查看代码修改后的效果，而无需每次手动运行构建命令。这对于提高开发效率和快速迭代非常有帮助。</p></li></ol><h1 id="webpack-serve是什么意思？帮我详细解释并举例说明"><a href="#webpack-serve是什么意思？帮我详细解释并举例说明" class="headerlink" title="webpack serve是什么意思？帮我详细解释并举例说明"></a>webpack serve是什么意思？帮我详细解释并举例说明</h1><p><code>webpack serve</code> 是一个由 webpack 提供的用于开发环境的开发服务器。它是 webpack-dev-server 的最新版本，提供了一个方便的开发服务器，可以在本地快速启动一个开发环境，自动重新编译和刷新页面，同时支持热模块替换（Hot Module Replacement，HMR）功能。</p><p>以下是对 <code>webpack serve</code> 的详细解释和示例说明：</p><ol><li><p><code>webpack serve</code> 的使用说明：</p><ul><li>通过在终端中执行 <code>webpack serve</code> 命令，可以启动 webpack 的开发服务器。</li><li>开发服务器将会监听指定的端口，默认为 8080，你可以通过配置选项来更改端口和其他设置。</li><li>它会在内存中构建项目，并将编译后的文件提供给浏览器访问，而无需在每次更改时重新写入硬盘。</li><li>开发服务器还支持热模块替换（HMR），这意味着修改代码后，它会在不刷新整个页面的情况下，只更新发生更改的模块。</li></ul></li><li><p>示例：</p><p>假设你有一个 Webpack 配置文件 <code>webpack.config.js</code>，其中的入口文件是 <code>index.js</code>，你可以通过以下命令来使用 <code>webpack serve</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack serve</span><br></pre></td></tr></table></figure><p>这会启动 webpack 的开发服务器，默认监听在 <code>localhost:8080</code>。你可以在浏览器中访问 <code>http://localhost:8080</code> 来查看你的项目。</p><p>当你使用 <code>webpack serve</code> 时，你可以对代码进行修改并保存，在浏览器中实时查看更改的效果。同时，当模块发生更改时，Webpack 会利用热模块替换（HMR）功能，只更新发生更改的模块，而不会刷新整个页面。</p><p>你可以尝试在编辑器中修改代码并保存，然后观察浏览器中的结果。你应该能够看到只有发生更改的部分被更新，而不会重新加载整个页面。</p><p><code>webpack serve</code> 还提供了一些可选的配置选项，例如更改监听端口、配置代理、启用 HTTPS 等。你可以根据具体的需求在配置文件中进行相应的配置。</p><p>使用 <code>webpack serve</code> 可以极大地提高前端开发的效率，快速反馈修改后的结果，同时支持热模块替换，使得开发过程更加顺畅和高效。</p></li></ol><h1 id="Webpack如何引入第三方库？"><a href="#Webpack如何引入第三方库？" class="headerlink" title="Webpack如何引入第三方库？"></a>Webpack如何引入第三方库？</h1><p>在 Webpack 中引入第三方库有几种方式，具体取决于你想如何处理这些库。下面我将介绍两种常用的方式：</p><ol><li><p>使用全局变量或 CDN 引入：</p><p>如果你使用的第三方库已经通过 <code>&lt;script&gt;</code> 标签引入到 HTML 页面中，你可以直接在你的 JavaScript 代码中使用它们，而无需在 Webpack 配置中进行额外的处理。</p><p>例如，在你的 HTML 文件中引入 jQuery 库：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在你的 JavaScript 文件中就可以直接使用 <code>$</code> 或 <code>jQuery</code> 对象，因为它们是全局变量：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#myElement&#x27;</span>).addClass(<span class="string">&#x27;active&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这种方式适用于一些全局对象或库，它们不需要通过模块化的方式进行引入。</p></li><li><p>使用模块化引入：</p></li></ol><p>如果你希望在 Webpack 中使用模块化的方式引入第三方库，你可以通过以下步骤进行配置：</p><ol><li><p>首先，通过 npm 或 yarn 安装你想使用的第三方库：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install 第三方库名 --save</span><br></pre></td></tr></table></figure></li><li><p>在你的 JavaScript 代码中通过 <code>import</code> 或者 <code>require</code> 引入这些库：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 第三方库名 <span class="keyword">from</span> <span class="string">&#x27;第三方库名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 require：</span></span><br><span class="line"><span class="keyword">const</span> 第三方库名 = <span class="built_in">require</span>(<span class="string">&#x27;第三方库名&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>在你的 Webpack 配置文件中，通过配置 <code>resolve.modules</code> 选项，告诉 Webpack 哪些目录中可以找到你安装的第三方库：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">modules</span>: [<span class="string">&#x27;node_modules&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，当你在代码中引入第三方库时，Webpack 就会在这些指定的目录中查找并解析这些库。</p><p>这种方式适用于大部分需要模块化引入的第三方库，这样可以更好地与 Webpack 的打包过程结合，并允许你使用更多 Webpack 的功能，如代码拆分、优化和压缩等。</p></li></ol><p>无论你选择哪种方式，都可以在 Webpack 中成功引入第三方库。具体方式取决于你的需求和项目配置。</p><h1 id="css-loader和style-loader是什么意思？帮我详细解释并举例说明"><a href="#css-loader和style-loader是什么意思？帮我详细解释并举例说明" class="headerlink" title="css-loader和style-loader是什么意思？帮我详细解释并举例说明"></a>css-loader和style-loader是什么意思？帮我详细解释并举例说明</h1><ol><li><p><code>css-loader</code>:</p><p><code>css-loader</code>是用于处理CSS文件的Webpack Loader之一。它的作用是将CSS文件转换为JavaScript模块，以便在项目中引入和使用CSS样式。</p><p>当你使用<code>css-loader</code>时，它会分析CSS文件，并处理其中的<code>@import</code>和<code>url()</code>等导入语句，以确保正确地解析和加载CSS文件的依赖资源，如其他CSS文件、图片等。</p><p>举个例子，假设在一个JavaScript文件中引入了一个CSS文件（例如<code>import &#39;./styles.css&#39;;</code>），使用<code>css-loader</code>后，CSS文件会被转换为一个JavaScript模块，类似于：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// CSS文件的内容被包裹在一个JavaScript模块中</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在构建过程中，Webpack会将CSS文件当作模块进行处理，并根据需要对其进行解析、压缩等操作。</p></li><li><p><code>style-loader</code>:</p></li></ol><p><code>style-loader</code>是另一个Webpack Loader，它的作用是将CSS样式通过动态创建<code>&lt;style&gt;</code>标签的方式插入到HTML页面中。</p><p>当你使用<code>style-loader</code>时，它会将经过<code>css-loader</code>处理后的CSS样式以内联方式插入到最终生成的HTML页面中，使得样式可以生效。</p><p>举个例子，当你在JavaScript文件中引入一个CSS文件，并使用了<code>style-loader</code>时，Webpack会在最终生成的HTML文件中动态插入类似下面的<code>&lt;style&gt;</code>标签：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  <span class="comment">/* CSS样式被插入到这里 */</span></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这样，通过<code>style-loader</code>的处理，CSS样式将被应用到HTML页面上，从而使得页面能够正确显示所定义的样式。</p><p>综合使用<code>css-loader</code>和<code>style-loader</code>可以实现将CSS文件转换为JavaScript模块，并通过动态插入<code>&lt;style&gt;</code>标签的方式使CSS样式生效。这使得我们能够将CSS与JavaScript模块一起打包，并在浏览器中正确加载和应用样式。</p><p>在Webpack配置中，通常需要在<code>module.rules</code>中配置相应的Loader规则，如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上配置表示对匹配到的CSS文件，先使用<code>css-loader</code>进行处理，然后再使用<code>style-loader</code>处理。</p><h2 id="这么处理的好处"><a href="#这么处理的好处" class="headerlink" title="这么处理的好处"></a>这么处理的好处</h2><p>处理CSS文件的好处：</p><ol><li>模块化：通过将CSS文件转换为JavaScript模块，可以实现CSS的模块化管理。每个模块可以有自己的CSS样式，避免了全局命名冲突和样式覆盖的问题。</li><li>依赖管理：使用<code>css-loader</code>可以处理CSS文件中的<code>@import</code>和<code>url()</code>等导入语句，确保正确解析和加载CSS文件的依赖资源，如其他CSS文件、图片等。这样可以方便地管理CSS文件之间的依赖关系。</li><li>自动前缀：通过使用适当的插件，<code>css-loader</code>可以自动为CSS属性添加浏览器前缀，以保证在不同浏览器中的兼容性。</li><li>代码拆分和按需加载：使用<code>style-loader</code>将CSS样式内联到HTML页面中，可以使得在页面加载时只加载必需的CSS样式，而不是一次性加载所有的CSS文件。这提高了页面加载性能，并允许采用代码拆分等优化策略。</li></ol><p>如果不使用<code>css-loader</code>和<code>style-loader</code>来处理CSS文件，可能会面临以下坏处：</p><ol><li>额外的网络请求：在没有使用Webpack等构建工具的情况下，网页需要通过<code>&lt;link&gt;</code>标签或内联样式的方式引入CSS文件。这将导致额外的网络请求，在页面加载时需要多次与服务器进行交互，增加了页面加载时间。</li><li>全局污染：如果不对CSS进行模块化处理，可能会出现全局命名冲突的问题。不同的样式文件可能包含相同的类名或选择器，导致样式冲突和覆盖，增大了维护和调试的难度。</li><li>难以管理依赖：在原始的CSS引入方式中，没有自动处理CSS文件之间的依赖关系。如果一个CSS文件依赖另一个CSS文件，需要手动在HTML文件中按正确的顺序引入。这增加了维护和修改CSS文件时的复杂性。</li><li>缺乏自动前缀：为了确保CSS样式在不同浏览器中的兼容性，通常需要手动添加浏览器前缀。没有自动前缀的处理，将会增加编写和维护CSS样式的工作量。</li></ol><p>综上所述，使用<code>css-loader</code>和<code>style-loader</code>能够带来诸多好处，包括模块化管理、依赖管理、自动前缀和按需加载等。而不使用这些处理方式，可能会导致网络请求增多、全局污染、依赖管理困难和缺乏自动前缀等问题。</p><h1 id="miniCSSExtractPlugin是什么意思？帮我详细解释并举例说明"><a href="#miniCSSExtractPlugin是什么意思？帮我详细解释并举例说明" class="headerlink" title="miniCSSExtractPlugin是什么意思？帮我详细解释并举例说明"></a>miniCSSExtractPlugin是什么意思？帮我详细解释并举例说明</h1><p>miniCSSExtractPlugin（正确的应为mini-css-extract-plugin）是一个用于将CSS样式从打包后的JavaScript文件中提取出来的webpack插件。</p><p>通常情况下，使用webpack构建项目时，CSS文件会通过style-loader将样式以内联的形式添加到HTML页面中或者作为JavaScript模块动态注入到页面中。而mini-css-extract-plugin的作用是将CSS样式从JavaScript文件中分离出来，生成独立的CSS文件。</p><p>这种分离的好处是可以将CSS文件进行缓存，减少页面加载时间，提高性能。此外，生成的独立CSS文件可以通过URL引入，进行浏览器缓存和并行下载，更好地利用浏览器的并发请求能力。</p><p>下面是一个示例，展示如何在webpack中使用mini-css-extract-plugin插件：</p><p>首先，安装插件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mini-css-extract-plugin</span><br></pre></td></tr></table></figure><p>然后，在webpack配置文件中引入插件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...其他配置项</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;styles.css&#x27;</span> <span class="comment">// 设置生成的独立CSS文件的名称</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上配置中，我们定义了一个处理<code>.css</code>文件的规则，使用<code>MiniCssExtractPlugin.loader</code>将CSS样式提取到独立的文件中，然后使用<code>css-loader</code>加载并处理CSS文件。</p><p>最后，通过<code>new MiniCssExtractPlugin()</code>创建一个插件实例，在<code>plugins</code>数组中添加该实例。其中，可以通过<code>filename</code>选项来设置生成的独立CSS文件的名称。</p><p>当进行项目构建时，webpack会根据上述配置，将CSS样式提取到指定的文件中，生成单独的<code>styles.css</code>文件，可以通过<code>&lt;link&gt;</code>标签在HTML页面中引入。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!-- 页面内容 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这样，在浏览器加载页面时，可以并行地下载JavaScript文件和CSS文件，提高页面加载速度和性能。</p><h1 id="Webpack如何引入图片？"><a href="#Webpack如何引入图片？" class="headerlink" title="Webpack如何引入图片？"></a>Webpack如何引入图片？</h1><p>在Webpack中，你可以使用<code>file-loader</code>或<code>url-loader</code>来处理图片文件的引入。</p><p>首先，你需要安装这些加载器（如果尚未安装）：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader url-loader --save-dev</span><br></pre></td></tr></table></figure><p>接下来，在Webpack的配置文件中添加相应的规则来处理图片文件。以下是一个示例配置：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">limit</span>: <span class="number">8192</span>, <span class="comment">// 图片大小低于8KB将转为base64格式</span></span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;images/[name].[hash:8].[ext]&#x27;</span> <span class="comment">// 输出的文件名格式</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述配置中，我们使用了<code>url-loader</code>来处理图片文件。通过<code>test</code>属性指定了要匹配的文件类型（在示例中是png、jpg、jpeg、gif和svg格式的图片）。然后在<code>use</code>中指定了使用的加载器。</p><p><code>url-loader</code>可以将文件转换为DataURL格式（Base64编码），也可以将大于指定大小（在示例中是8KB）的文件输出到输出目录，并产生一个公开可访问的URL。这样，小图片可以直接嵌入到CSS或HTML中，而大图片将作为独立的文件输出。</p><p>在你的代码中，通过使用相对路径引入图片文件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> image <span class="keyword">from</span> <span class="string">&#x27;./path/to/image.png&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> image = <span class="built_in">require</span>(<span class="string">&#x27;./path/to/image.png&#x27;</span>);</span><br></pre></td></tr></table></figure><p>以上代码将会将图片文件作为模块导入，并将其赋值给变量<code>image</code>。</p><p>如果使用了<code>url-loader</code>，当图片文件的大小小于指定的限制时（在示例中是8KB），<code>url-loader</code>会将图片转换为DataURL格式，然后将DataURL导入到代码中。</p><p>如果图片文件大小超过了指定的限制，<code>url-loader</code>会将文件输出到指定的输出目录，并返回图片的公开URL。</p><p>这样，你就可以在Webpack中正确地引入和处理图片文件了。</p><h1 id="Webpack如何做到按需加载"><a href="#Webpack如何做到按需加载" class="headerlink" title="Webpack如何做到按需加载"></a>Webpack如何做到按需加载</h1><p>Webpack通过动态导入的方式实现按需加载（也称为懒加载）。懒加载是一种优化技术，它允许将代码分割成多个小块，并在需要时按需加载这些块，而不是一次性加载所有代码。</p><p>以下是Webpack中实现按需加载的几种方式：</p><ol><li><p>使用动态 import：</p><p>在代码中使用<code>import()</code>语法来动态导入模块。这将返回一个Promise，可以使用<code>then</code>方法来处理导入的结果。Webpack会将动态导入的模块拆分成一个单独的文件，然后在需要时按需加载。</p><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./module&#x27;</span>).then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理动态导入的模块</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用React的lazy函数和Suspense组件（适用于React项目）：</p><p>React提供了<code>lazy</code>函数和<code>Suspense</code>组件来实现组件的按需加载。<code>lazy</code>函数接受一个动态导入的函数作为参数，并返回一个懒加载的组件。<code>Suspense</code>组件用于在懒加载完成之前显示一个加载状态。</p><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; lazy, Suspense &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./MyComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Webpack的代码分割配置：</p><p>在Webpack的配置文件中，可以使用特定的配置来实现代码分割。可以使用<code>optimization.splitChunks</code>配置选项将代码分割成不同的块，然后按需加载这些块。</p><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>这些方式都可以按需加载模块或组件，从而实现优化的代码加载策略。根据你的具体项目需求，选择适合的方式来实现按需加载。</p><h2 id="举例一个具体的业务场景，什么时候用Webpack懒加载？"><a href="#举例一个具体的业务场景，什么时候用Webpack懒加载？" class="headerlink" title="举例一个具体的业务场景，什么时候用Webpack懒加载？"></a>举例一个具体的业务场景，什么时候用Webpack懒加载？</h2><p>假设你正在开发一个电子商务网站，其中包含多个页面和功能。以下是一个具体的业务场景，说明何时可以使用Webpack的懒加载功能：</p><p>假设你的电子商务网站有一个商品列表页面（ProductList）和一个商品详情页（ProductDetails）。用户首先访问商品列表页面，然后点击某个商品来查看详细信息。</p><p>在这种情况下，你可以使用Webpack的懒加载来优化网站的加载性能和用户体验。</p><ol><li><p>商品列表页面（ProductList）：</p><p>商品列表页面是用户首次访问的页面，因此它是一个必需的初始加载项，可以在应用的主入口文件中引入。这样，在初始加载时，所有与商品列表页面相关的代码都会被捆绑并一起加载。</p></li><li><p>商品详情页（ProductDetails）：</p><p>商品详情页是用户从商品列表页面导航到的页面。为了避免初始加载时过多的代码负担和减少初始加载时间，可以将商品详情页（ProductDetails）模块设为懒加载。当用户点击商品列表中的某个商品时，只有与商品详情页相关的代码才会按需加载。这样可以将商品详情页的代码与其他页面的代码分离，减少初始加载文件的大小。</p></li></ol><p>通过使用Webpack的懒加载，可以实现以下优势：</p><ul><li>加快初始页面的加载时间：用户首次访问时只需加载商品列表页面所需的代码，而不会加载整个应用的所有代码。</li><li>提高页面的响应速度：当用户点击某个商品查看详情时，只需加载与商品详情页相关的代码，减少了用户在浏览商品列表时的等待时间。</li><li>减少初始加载文件的大小：将不同页面的代码拆分成多个模块，只按需加载需要的模块，从而减小初始加载文件的体积。</li></ul><p>需要注意的是，懒加载并不适用于所有业务场景。它最适合用于那些具有多个页面或功能模块，并且页面之间的初始加载时间相对较长的应用。在设计应用时，你可以根据具体情况来决定哪些模块可以进行懒加载，以获得最佳的性能和用户体验。</p><h1 id="webpack和框架VUE、React之间的联系是什么？为什么说VUE、React也是模块化工程？"><a href="#webpack和框架VUE、React之间的联系是什么？为什么说VUE、React也是模块化工程？" class="headerlink" title="webpack和框架VUE、React之间的联系是什么？为什么说VUE、React也是模块化工程？"></a>webpack和框架VUE、React之间的联系是什么？为什么说VUE、React也是模块化工程？</h1><p>Webpack和Vue、React框架之间有密切的联系，而且Vue和React框架本身也是模块化工程的实现方式。下面我会一一解释它们之间的联系和为什么Vue和React也被称为模块化工程。</p><ol><li><p>Webpack与Vue、React的联系：</p><p>Webpack是一个现代的静态模块打包工具，它可以将各种资源（JavaScript、CSS、图片等）视为模块，并根据这些模块之间的依赖关系进行打包和构建。Vue和React框架都使用Webpack来构建和打包应用程序。</p><p>在Vue和React应用中，各个组件可以被看作独立的模块，它们具有自己的样式、逻辑和模板。Webpack的作用是将这些组件及其相关的资源打包为最终可用的JavaScript文件，以便在浏览器中运行。Webpack可以解析模块间的依赖关系，并根据需要进行代码分割和懒加载，从而优化应用程序的加载性能。</p><p>此外，Webpack还提供了一系列功能，如代码压缩、文件合并、热模块替换（HMR）等，使得开发者能够更高效地开发、构建和部署Vue和React应用程序。</p></li><li><p>Vue和React作为模块化工程：</p><p>Vue和React框架都采用了组件化的开发方式，将应用程序划分为多个小而可重用的组件。这些组件具有自己的状态、样式和行为，并可以在不同的上下文中进行组合和复用。这种模块化的开发方式带来了许多优势，如代码的可维护性、可测试性和可重用性。</p><p>在Vue和React应用中，组件通常以模块的形式存在，通过导入和导出语法进行模块间的引用和组合。这使得我们可以将不同功能的代码块封装为独立的模块，然后在需要的地方进行引用和使用。</p><p>这种模块化的开发方式与Webpack的思想相呼应。Webpack可以将Vue和React应用程序中的各个组件及其依赖的模块按需打包和加载，以实现更高效的资源管理和加载。同时，Webpack还能处理应用程序中的样式、图片等其他资源，并在构建过程中进行代码优化和压缩，以提高应用程序的性能。</p></li></ol><p>综上所述，Webpack、Vue和React之间存在密切的联系，它们共同推动了前端开发的模块化和工程化发展。Webpack提供了强大的打包工具，帮助Vue和React开发者构建高效的应用程序。而Vue和React框架本身则采用了模块化的开发方式，使得应用程序可以被切分为多个独立的组件进行开发和管理，从而提高了代码的可维护性和可重用性。</p><h1 id="如果我的项目是Vue或者React，本身就是模块化工程，那么还需要用到Webpack吗？"><a href="#如果我的项目是Vue或者React，本身就是模块化工程，那么还需要用到Webpack吗？" class="headerlink" title="如果我的项目是Vue或者React，本身就是模块化工程，那么还需要用到Webpack吗？"></a>如果我的项目是Vue或者React，本身就是模块化工程，那么还需要用到Webpack吗？</h1><p>如果你的项目是基于Vue或React框架，并且已经使用了模块化开发方式，那么使用Webpack仍然是有意义的，并且通常是必要的。虽然Vue和React本身支持模块化开发，但Webpack提供了更强大的功能来处理和管理模块化的项目，以及优化应用程序的构建和性能。</p><p>以下是为什么你可能需要使用Webpack的原因：</p><ol><li>模块打包：Webpack的核心功能之一是将各种资源（JavaScript、CSS、图片等）视为模块，并根据它们之间的依赖关系进行打包。它能够将你的Vue或React应用中的各个组件及其相关资源打包为最终可用的JavaScript文件，在浏览器中运行。Webpack可以通过代码分割和懒加载来优化应用程序的加载性能。</li><li>自动化工作流：Webpack提供了许多功能和插件，可以帮助你自动完成诸如代码压缩、文件合并、代码分割、热模块替换（HMR）等任务。这些功能可以提高开发效率，简化工作流程，以及优化生产环境中的应用程序性能。</li><li>资源优化：Webpack可以帮助你处理CSS、图片、字体等其他资源，并进行优化、压缩和合并，以减少文件大小和加载时间。它还支持对JavaScript代码进行压缩和混淆，以减少文件体积并提高执行速度。</li><li>插件生态系统：Webpack拥有庞大的插件生态系统，可以扩展和定制其功能。这些插件可以帮助你解决特定的问题、优化构建过程、增加功能等。</li></ol><p><strong>需要注意的是，当你使用Vue CLI或Create React App等脚手架工具创建Vue或React项目时，它们已经默认集成了Webpack，并进行了预配置，使得你可以方便地进行开发和构建。这样的脚手架工具为你提供了Webpack的配置和功能，你只需关注业务逻辑即可。</strong></p><p>综上所述，尽管Vue和React本身已经支持模块化开发，但使用Webpack仍然是一个常见且有益的选择，可以提供更多的工具和功能来优化和管理你的项目。</p>]]></content:encoded>
      
      
      <category domain="https://dunyusong.github.io/categories/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <category domain="https://dunyusong.github.io/tags/Webpack/">Webpack</category>
      
      
      <comments>https://dunyusong.github.io/post/Webpack%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>前端学习踩坑小记-padding和margin</title>
      <link>https://dunyusong.github.io/post/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0-padding%E5%92%8Cmargin.html</link>
      <guid>https://dunyusong.github.io/post/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0-padding%E5%92%8Cmargin.html</guid>
      <pubDate>Fri, 24 Mar 2023 13:41:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;最近发现产品有个小问题，有序列表和无序列表的序列号展示不全：&lt;/p&gt;
&lt;img src=&quot;/post/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0-padding%E5%92</description>
        
      
      
      
      <content:encoded><![CDATA[<p>最近发现产品有个小问题，有序列表和无序列表的序列号展示不全：</p><img src="/post/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0-padding%E5%92%8Cmargin/WeChate95435fafc2db9e10d751ccaee828f31.png" class alt="问题"><p>第一反应是设置了margin-left，发现没解决，然后我去问了chatGPT，它给出的答案是设置padding-left。</p><p>又让它解释了区别：</p><ul><li>padding-left属性是用来设置元素的内边距（padding）的左边距，它可以用来控制元素内容与元素边框之间的距离。</li><li>margin-left属性是用来设置元素的外边距（margin）的左边距，它可以用来控制元素与其他元素之间的距离。</li></ul><p>用一张图来更直观的说明区别：</p><img src="/post/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0-padding%E5%92%8Cmargin/margin-padding.png" class alt="问题">]]></content:encoded>
      
      
      
      <category domain="https://dunyusong.github.io/tags/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/">产品开发日记</category>
      
      <category domain="https://dunyusong.github.io/tags/CSS/">CSS</category>
      
      
      <comments>https://dunyusong.github.io/post/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0-padding%E5%92%8Cmargin.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
